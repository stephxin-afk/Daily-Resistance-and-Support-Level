# -*- coding: utf-8 -*-
"""
Grouped report per seed ticker:
- Read seeds from env TICKERS (fallback to DEFAULT_TICKERS)
- For each seed, fetch peers from Finnhub (if FINNHUB_API_KEY is set)
- Build one table per seed: [seed] + peers (unique), compute pivots and %chg
- Outputs:
  report.pdf  (cover + one landscape page per seed)
  index.html  (one section per seed, responsive)
  table.csv   (all rows with column 'Group' = '<SEED> + Peers')

Optional env:
- FINNHUB_API_KEY
- TICKERS            e.g. "AMD, HD"
- DEFAULT_TICKERS    e.g. "NVDA,AMD"
- REPORT_URL         e.g. https://<user>.github.io/<repo>/report.pdf
- SITE_URL           e.g. https://<user>.github.io/<repo>/
- WECHAT_SCT_SENDKEY (ServerChan Turbo)
- PUSHPLUS_TOKEN     (PushPlus)

Deps: yfinance, pandas, matplotlib, requests
"""

import os
import sys
import json
import traceback
from datetime import datetime

import requests
import pandas as pd
import yfinance as yf
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages

TITLE = "Daily Pivot Levels (Ticker + Peers)"
SUB   = "Formulas: P=(H+L+C)/3; S1=2P‚àíH; S2=P‚àí(H‚àíL); R1=2P‚àíL; R2=P+(H‚àíL)"
OUT   = "report.pdf"

# Ê∏≤ÊüìÂáèÂè∑
matplotlib.rcParams["axes.unicode_minus"] = False

def log(msg: str):
    print(f"[{datetime.now():%H:%M:%S}] {msg}", flush=True)

def getenv(name: str, default: str = "") -> str:
    v = os.getenv(name, default)
    return (v or "").strip()

def parse_seeds() -> list[str]:
    raw = getenv("TICKERS") or getenv("DEFAULT_TICKERS")
    if not raw:
        # Ê≤°ÈÖçÁΩÆÂ∞±Áî® NVDA ‰Ωú‰∏∫ÈªòËÆ§Á§∫‰æã
        raw = "NVDA"
    # ÊîØÊåÅÈÄóÂè∑„ÄÅÁ©∫Ê†º„ÄÅÂàÜÂè∑ÂàÜÈöî
    parts = [p.strip().upper() for p in
             raw.replace(";", ",").replace(" ", ",").split(",") if p.strip()]
    # ÂéªÈáç‰ΩÜ‰øùÁïôÈ°∫Â∫è
    seen, out = set(), []
    for p in parts:
        if p not in seen:
            seen.add(p); out.append(p)
    return out

def get_peers_from_finnhub(symbol: str) -> list[str]:
    key = getenv("FINNHUB_API_KEY")
    if not key:
        return []
    url = f"https://finnhub.io/api/v1/stock/peers?symbol={symbol}&token={key}"
    try:
        r = requests.get(url, timeout=12)
        r.raise_for_status()
        peers = r.json()
        if isinstance(peers, list):
            peers = [p for p in peers if isinstance(p, str) and p.upper() != symbol.upper()]
            return peers
    except Exception as e:
        log(f"Finnhub peers error for {symbol}: {e}")
    return []

def pivots(h: float, l: float, c: float):
    P = (h + l + c) / 3.0
    R1 = 2 * P - l
    S1 = 2 * P - h
    R2 = P + (h - l)
    S2 = P - (h - l)
    return P, S1, S2, R1, R2

def fetch_latest_row(ticker: str) -> dict:
    # ÂèñËøë 14 Â§©ÔºåÁ°Æ‰øùËÉΩÊãøÂà∞ÊúÄËøë‰∏§Ê†πÊúâÊïàÊó•Á∫ø
    df = yf.download(ticker, period="14d", interval="1d", auto_adjust=False, progress=False)
    if df is None or df.empty:
        raise RuntimeError(f"yfinance empty for {ticker}")
    df = df.dropna(subset=["High", "Low", "Close"])
    if len(df) < 2:
        raise RuntimeError(f"not enough bars for {ticker}")
    last2 = df.tail(2).reset_index(drop=False)
    cur  = last2.iloc[1]
    prev = last2.iloc[0]
    # yfinance ÊúâÊó∂ËøîÂõû numpy Á±ªÂûãÔºåÁî® float() Áªü‰∏Ä
    h = float(cur["High"]); l = float(cur["Low"]); c = float(cur["Close"])
    pc = float(prev["Close"])
    dt = cur["Date"] if "Date" in cur else df.index[-1]
    date_str = dt.date().isoformat() if hasattr(dt, "date") else str(dt)[:10]
    return {"Ticker": ticker, "Date": date_str, "High": h, "Low": l, "Close": c, "PrevClose": pc}

def build_group(seed: str, max_peers: int = 6) -> pd.DataFrame:
    peers = get_peers_from_finnhub(seed)
    # peers ÈôêÂà∂Êï∞ÈáèÔºåÈÅøÂÖçË°®Ê†ºÂ§™ÈïøÔºõ‰ºòÂÖà‰øùÁïôËøîÂõûÈ°∫Â∫è
    peers = [p.upper() for p in peers[:max_peers] if isinstance(p, str)]
    tickers = [seed.upper()] + [p for p in peers if p != seed.upper()]
    rows = []
    for t in tickers:
        try:
            r = fetch_latest_row(t)
            P, S1, S2, R1, R2 = pivots(r["High"], r["Low"], r["Close"])
            chg_pct = (r["Close"] - r["PrevClose"]) / r["PrevClose"] * 100.0 if r["PrevClose"] else 0.0
            r.update({
                "Pivot P": round(P, 2), "S1": round(S1, 2), "S2": round(S2, 2),
                "R1": round(R1, 2), "R2": round(R2, 2),
                "High": round(r["High"], 2), "Low": round(r["Low"], 2),
                "Close": round(r["Close"], 2), "PrevClose": round(r["PrevClose"], 2),
                "% Chg": round(chg_pct, 2)
            })
            rows.append(r)
        except Exception as e:
            log(f"Fetch failed for {t}: {e}")
    if not rows:
        raise RuntimeError(f"No data for seed {seed}.")
    cols = ["Ticker", "Date", "High", "Low", "Close", "PrevClose", "% Chg", "Pivot P", "S1", "S2", "R1", "R2"]
    df = pd.DataFrame(rows)[cols]
    df.insert(0, "Group", f"{seed.upper()} + Peers")
    return df

def write_pdf_grouped(grouped: dict[str, pd.DataFrame], path: str):
    with PdfPages(path) as pdf:
        # Â∞ÅÈù¢
        plt.figure(figsize=(8.27, 11.69))  # A4 Á´ñ
        plt.axis("off")
        plt.text(0.5, 0.80, TITLE, ha="center", fontsize=20, fontweight="bold")
        plt.text(0.5, 0.73, SUB.replace("‚àí", "-"), ha="center", fontsize=10)
        plt.text(0.5, 0.68, f'Generated: {datetime.now():%Y-%m-%d %H:%M}', ha="center", fontsize=9)
        pdf.savefig(bbox_inches="tight"); plt.close()

        # ÊØè‰∏™ÁßçÂ≠êÂçïÁã¨‰∏ÄÈ°µÔºàÊ®™ÂêëÔºâ
        for seed, df in grouped.items():
            plt.figure(figsize=(11.69, 8.27))  # A4 Ê®™
            plt.axis("off")
            title = f"{seed} + Peers"
            plt.text(0.5, 0.95, title, ha="center", fontsize=16, fontweight="bold")
            table = plt.table(cellText=df.drop(columns=["Group"]).values,
                              colLabels=df.drop(columns=["Group"]).columns,
                              loc="center")
            table.auto_set_font_size(False)
            table.set_fontsize(10)
            table.scale(1.2, 1.3)
            pdf.savefig(bbox_inches="tight"); plt.close()

def write_csv(df_all: pd.DataFrame, path="table.csv"):
    df_all.to_csv(path, index=False)

def write_html_grouped(grouped: dict[str, pd.DataFrame], pdf_url: str):
    # ÁõÆÂΩï
    nav = "".join(f'<a class="chip" href="#g-{seed}">{seed}</a>' for seed in grouped.keys())
    # ÊØè‰∏™ÂàÜÂå∫
    sections = []
    for seed, df in grouped.items():
        # Ë°åÊ∏≤ÊüìÔºàÊ∂®Ë∑åÂπÖ‰∏äËâ≤Ôºâ
        body = []
        cols = list(df.columns)
        # ÊòæÁ§∫Êó∂‰∏çÈúÄË¶Å Group Âàó
        cols_show = [c for c in cols if c != "Group"]
        for row in df[cols_show].itertuples(index=False):
            cells = []
            for c, v in zip(cols_show, row):
                if c == "% Chg":
                    try:
                        num = float(v)
                        cls = "up" if num >= 0 else "down"
                        cells.append(f'<td class="{cls}">{num:.2f}%</td>')
                    except Exception:
                        cells.append(f"<td>{v}</td>")
                else:
                    cells.append(f"<td>{v}</td>")
            body.append("<tr>" + "".join(cells) + "</tr>")
        html_rows = "\n".join(body)
        thead = "".join(f"<th>{h}</th>" for h in cols_show)
        sections.append(f"""
<section id="g-{seed}">
  <h2>{seed} + Peers</h2>
  <div class="table-wrap">
    <table>
      <thead><tr>{thead}</tr></thead>
      <tbody>
        {html_rows}
      </tbody>
    </table>
  </div>
</section>
""")
    html = f"""<!doctype html>
<html lang="en"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>{TITLE}</title>
<style>
  body {{ font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans", sans-serif; margin: 16px; }}
  h1 {{ font-size: 1.25rem; margin: 0 0 6px; }}
  h2 {{ font-size: 1.05rem; margin: 16px 0 8px; }}
  .sub {{ color:#666; font-size:.85rem; margin-bottom:10px; }}
  .bar {{ display:flex; gap:8px; margin:10px 0; flex-wrap:wrap; }}
  a.btn {{ text-decoration:none; padding:10px 14px; border-radius:10px; border:1px solid #ddd; }}
  .chips {{ display:flex; flex-wrap:wrap; gap:8px; margin:10px 0; }}
  .chip {{ display:inline-block; padding:6px 10px; border:1px solid #eee; border-radius:999px; font-size:.9rem; }}
  .table-wrap {{ overflow-x:auto; -webkit-overflow-scrolling:touch; border:1px solid #eee; border-radius:10px; }}
  table {{ border-collapse:collapse; width:100%; font-size:14px; }}
  th, td {{ white-space:nowrap; padding:9px 10px; border-bottom:1px solid #f0f0f0; }}
  th {{ position:sticky; top:0; background:#fafafa; text-align:left; }}
  td.up {{ color:#14804a; font-weight:600; }}
  td.down {{ color:#d12c2c; font-weight:600; }}
  @media (max-width:480px) {{
    table {{ font-size:13px; }}
    th, td {{ padding:8px 8px; }}
  }}
</style>
</head>
<body>
  <h1>{TITLE}</h1>
  <div class="sub">{SUB}</div>

  <div class="bar">
    <a class="btn" href="{pdf_url}">üìÑ Download PDF</a>
    <a class="btn" href="table.csv">‚¨áÔ∏è Download CSV</a>
  </div>

  <div class="chips">
    {nav}
  </div>

  {''.join(sections)}

  <div class="sub" style="margin-top:10px;color:#888;">Updated at: {datetime.now():%Y-%m-%d %H:%M}</div>
</body></html>"""
    with open("index.html", "w", encoding="utf-8") as f:
        f.write(html)

def push_serverchan(sendkey: str, title: str, content_md: str) -> bool:
    if not sendkey:
        return False
    try:
        r = requests.post(
            f"https://sctapi.ftqq.com/{sendkey}.send",
            data={"title": title, "desp": content_md},
            timeout=15,
        )
        r.raise_for_status()
        return r.ok
    except Exception as e:
        log(f"[SCT] {e}")
        return False

def push_pushplus(token: str, title: str, content_html: str) -> bool:
    if not token:
        return False
    try:
        r = requests.post(
            "https://www.pushplus.plus/send",
            json={"token": token, "title": title, "content": content_html, "template": "html"},
            timeout=15,
        )
        r.raise_for_status()
        return r.ok
    except Exception as e:
        log(f"[PushPlus] {e}")
        return False

if __name__ == "__main__":
    try:
        seeds = parse_seeds()
        log(f"Seeds: {seeds}")

        grouped: dict[str, pd.DataFrame] = {}
        frames = []
        for seed in seeds:
            try:
                df = build_group(seed)
                grouped[seed] = df
                frames.append(df)
                log(f"[{seed}] rows={len(df)}")
            except Exception as e:
                log(f"[{seed}] failed: {e}")

        if not frames:
            raise RuntimeError("No groups built; check seeds and network.")

        df_all = pd.concat(frames, ignore_index=True)
        write_csv(df_all, "table.csv")
        log("Wrote table.csv")

        write_pdf_grouped(grouped, OUT)
        log(f"Wrote {OUT}")

        report_url = getenv("REPORT_URL") or "report.pdf"
        write_html_grouped(grouped, report_url)
        log("Wrote index.html")

        # ÈÄöÁü•
        site_url = getenv("SITE_URL")
        title = "Daily Pivot ‚Äî Grouped by Seeds"
        md_msg = (
            f"**{title}**\n\n"
            + (f"[üì± Online view]({site_url})\n\n" if site_url else "")
            + f"[üìÑ Download PDF]({report_url})"
        )
        html_msg = (
            f"<b>{title}</b><br>"
            + (f"<a href=\"{site_url}\">üì± Online view</a><br>" if site_url else "")
            + f"<a href='{report_url}'>üìÑ Download PDF</a>"
        )
        ok_sct = push_serverchan(getenv("WECHAT_SCT_SENDKEY"), title, md_msg)
        ok_pp  = push_pushplus(getenv("PUSHPLUS_TOKEN"), title, html_msg)
        log(f"[Notify] ServerChan={ok_sct}  PushPlus={ok_pp}")

    except Exception:
        log("FATAL ERROR:\n" + "".join(traceback.format_exception(*sys.exc_info())))
        raise
